<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="distributor$.html">distributor$</a><ul class='methods'><li data-type='method'><a href="distributor$.html#.next">next</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#attract">attract</a></li><li><a href="global.html#ofHot">ofHot</a></li><li><a href="global.html#ofLast">ofLast</a></li><li><a href="global.html#permeate">permeate</a></li></ul>
</nav>

<div id="main">
    

    



    









    


    <section class="readme">
        <article><h1>rx-samsara</h1><p>一个<code>react</code>应用的数据流管理框架<br><br>它是在<strong>响应式编程</strong><code>js</code>库 <code>RxJS 6</code> 的基础上开发的，并且在使用时也需要依赖于<code>rxjs</code>的<code>observable</code>；<br><br>在<code>rx-samsara</code>的世界里，<code>observable</code>是基本单元(数据类型)，就像 <code>function</code>之于<code>javascript</code>。<br></p>
<p><a href="https://github.com/shayeLee/rx-samsara">源码地址: https://github.com/shayeLee/rx-samsara</a></p>
<h2>安装</h2><p>通过 npm</p>
<pre class="prettyprint source"><code>$ npm install rx-samsara --save</code></pre><h2>如何使用</h2><p>创建一个<code>observable</code></p>
<pre class="prettyprint source lang-javascript"><code>// testData.js

import { from } from &quot;rxjs&quot;;

const testData$ = from(
  new Promise(resolve => {
    setTimeout(() => {
      resolve(123);
    }, 800);
  })
);

export default testData$;</code></pre><p>创建一个名为<code>CompA</code>的<code>react</code>组件来消费可观察对象<code>testData$</code><br><br>注解<code>permeate</code>会提供观察者订阅以键值对传入的<code>observable</code>，并将观察者接收到的值根据对应的<code>key</code>转化为组件的<code>props</code></p>
<pre class="prettyprint source lang-javascript"><code>// compA.jsx

import { permeate } from &quot;rx-samsara&quot;;
import testData$ from &quot;testData&quot;;

@permeate({ testData: testData$ })
class CompA extends React.Component {
  render() {
    // this.props.testData === 123
    return &lt;div>{this.props.testData}&lt;/div>;
  }
}</code></pre><p>还可以再创建一个名为<code>CompB</code>的<code>react</code>组件，同样也来消费可观察对象<code>testData$</code>;</p>
<pre class="prettyprint source lang-javascript"><code>// compB.jsx

import { permeate } from &quot;rx-samsara&quot;;
import testData$ from &quot;testData&quot;;

@permeate({ testData: testData$ })
class CompB extends React.Component {
  render() {
    // this.props.testData === 123
    return &lt;div>{this.props.testData}&lt;/div>;
  }
}</code></pre><p>可观察对象<code>testData$</code>是可以供任何组件消费的，并且不受个数限制，当有组件使用的时候，<code>testData$</code>推送的数据会被转化为组件的属性(或更新已有的属性)。<br><br>但是我们可能会遇到这样的场景：在组件完成初始渲染之后，某些时刻需要更新<code>this.props.testData</code>的值。<br><br>这种场景下可以使用事件触发器<code>distributor$</code>，它提供了一个<code>next</code>函数使用户能够手动推送事件，然后我们需要对<code>testData$</code>做一些改造，使之能够接受<code>distributor$</code>推送的事件。</p>
<pre class="prettyprint source lang-javascript"><code>// testData.js

import { distributor$, attract } from &quot;rx-samsara&quot;;
import { from } from &quot;rxjs&quot;;
import { switchMap } from &quot;rxjs/operators&quot;;

// attract() 可以捕捉事件触发器推送的指定类型的事件，并返回一个包含值为该事件对象的observable
const testData$ = attract(&quot;refreshData&quot;).pipe(
  switchMap(event => {
    return from(
      new Promise(resolve => {
        setTimeout(() => {
          resolve(456);
        }, 800);
      })
    );
  })
);

export default testData$;</code></pre><p>当<code>distributor$</code>推送对应事件后，testData$ 就会向所有观察者推送数据(更新组件属性)</p>
<pre class="prettyprint source lang-javascript"><code>// compA.jsx

import { distributor$, permeate } from &quot;rx-samsara&quot;;
import testData$ from &quot;testData&quot;;

@permeate({ testData: testData$ })
class CompA extends React.Component {
  render() {
    // distributor$ 推送事件之后 this.props.testData === 456
    return (
      &lt;div>{this.props.testData}&lt;/div>
    )
  },
  componentDidMount() {
    distributor$.next(&quot;refreshData&quot;);
  }
}</code></pre></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Feb 27 2019 17:54:11 GMT+0800 (CST) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>